/*
=================================================
================== Code generated by ai =========
=================================================
*/
#include "generator.hpp"
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <filesystem>
#include <fstream>
#include <cctype>

bool str_ends_with(const std::string& str, const std::string& suffix) {
    if (suffix.size() > str.size()) return false;
    return str.compare(str.size() - suffix.size(), suffix.size(), suffix) == 0;
}

static const char* HELP_TEXT = R"(zapret2-strategy-generator (nfqws2 strategy generator)
Usage:
    nfqws2-strategy-gen --domains <list> --blob <preset-or-path> [--mode <mode>] [options]
    nfqws2-strategy-gen --help | -h

Required:
    --domains | -d <comma-separated-list>
        Target services / domain groups
        Supported: youtube | discord | instagram | twitter | reddit | pinterest
        (default per item → youtube)

    --blob | -b <preset-or-file-path>
        Fake TLS ClientHello source
        Built-in presets:
            gosuslugi | vk | vk_kyber | rutracker | max
            sberbank | google | iana | iana_big | random
        OR path to custom file (raw bytes):
            ./myhello.bin   /path/to/custom.dat   fakehello.raw
        (default → gosuslugi)

Optional:
    --mode   | -m <mode>
        simple   - lightweight / fast
        advanced - aggressive DPI bypass
        mixed    - simple + advanced (default)

    --count  | -c N
        Number of strategies per combination (default: 50)

    --format | -f txt|json
        Output format (default: txt)

Examples:
    nfqws2-strategy-gen -d youtube --blob gosuslugi
    nfqws2-strategy-gen -d discord,instagram -b random -m advanced -c 100
    nfqws2-strategy-gen --domains twitter -b ./custom_hello.bin --format json
    nfqws2-strategy-gen -d reddit -b /tmp/fake_tls_clienthello.dat -c 80
)";

int main(int argc, char** argv) {
    if (argc < 2) {
        std::cerr << HELP_TEXT << std::endl;
        return 1;
    }

    std::string domains_str;
    std::string blob_input;
    std::string mode = "mixed";
    std::string format = "txt";
    int count = 50;

    for (int i = 1; i < argc; ++i) {
        std::string a = argv[i];

        if (a == "--help" || a == "-h") {
            std::cout << HELP_TEXT << std::endl;
            return 0;
        }
        else if (a == "--domains"  || a == "-d") { if (++i < argc) domains_str = argv[i]; }
        else if (a == "--blob"     || a == "-b") { if (++i < argc) blob_input = argv[i]; }
        else if (a == "--mode"     || a == "-m") { if (++i < argc) mode = argv[i]; }
        else if (a == "--count"    || a == "-c") { if (++i < argc) count = std::stoi(argv[i]); }
        else if (a == "--format"   || a == "-f") { if (++i < argc) format = argv[i]; }
    }

    if (domains_str.empty() || blob_input.empty()) {
        std::cerr << "Error: --domains and --blob are required\n\n" << HELP_TEXT << std::endl;
        return 1;
    }

    std::string mode_lower = mode;
    std::transform(mode_lower.begin(), mode_lower.end(), mode_lower.begin(), ::tolower);
    if (mode_lower != "simple" && mode_lower != "advanced" && mode_lower != "mixed") {
        std::cerr << "Unknown mode '" << mode << "', using 'mixed'\n";
        mode = "mixed";
        mode_lower = "mixed";
    }

    std::vector<std::string> services;
    std::string current;
    for (char ch : domains_str + ',') {
        if (ch == ',') {
            if (!current.empty()) {
                std::string s = current;
                std::transform(s.begin(), s.end(), s.begin(), ::tolower);
                if (s != "youtube" && s != "discord" && s != "instagram" &&
                    s != "twitter" && s != "reddit" && s != "pinterest") {
                    std::cerr << "Unknown service '" << current << "', using 'youtube'\n";
                    s = "youtube";
                }
                services.push_back(s);
            }
            current.clear();
        } else {
            current += ch;
        }
    }
    if (services.empty()) services.push_back("youtube");

    std::string blob_name;
    std::string blob_for_filename;

    bool is_custom_file =
        blob_input.find('/')  != std::string::npos ||
        blob_input.find('\\') != std::string::npos ||
        str_ends_with(blob_input, ".bin") ||
        str_ends_with(blob_input, ".dat") ||
        str_ends_with(blob_input, ".raw") ||
        str_ends_with(blob_input, ".hello");

    std::string blob_path;

    if (is_custom_file) {

        std::filesystem::path p(blob_input);
        std::string stem = p.stem().string();

        for (char& c : stem) {
            if (std::string(" /\\:|?*\"<>").find(c) != std::string::npos)
                c = '_';
        }

        blob_name = "custom_" + stem;
        blob_path = blob_input;
    }
    else {
        blob_name = blob_input;
        blob_path.clear();
    }


    FastStrategyGenerator gen;

    for (const auto& service : services) {
        std::vector<std::string> strategies;

        if (mode_lower == "simple") {
            strategies = gen.gen_simple(
                service,
                blob_name,
                blob_path,
                count);
        }
        else if (mode_lower == "advanced") {
            strategies = gen.gen_advanced(
                service,
                blob_name,
                blob_path,
                count,
                0);
        }
        else {
            strategies = gen.gen_mixed(
                service,
                blob_name,
                blob_path,
                count);
        }



        std::string safe_blob = blob_name;
        for (char& c : safe_blob) {
            if (std::string(" /\\:|?*\"<>").find(c) != std::string::npos) c = '_';
        }

        std::string filename = "strategies_" + service + "_" + safe_blob + "_" + mode_lower + "." + format;

        if (format == "json") {
            gen.save_json(strategies, filename);
        } else {
            gen.save_txt(strategies, filename);
        }

        std::cout << service << " + " << blob_name
                    << " (" << mode_lower << ") -> "
                    << std::filesystem::absolute(filename).string() << "\n";
    }

    return 0;
}